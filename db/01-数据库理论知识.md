## 一、关系型数据库三大范式

1. 第一范式（1NF）：数据库中的每一列都是不可分割的原子数据项。
2. 第二范式（2NF）:每个非主属性完全依赖于键码。(关键：解决数据冗余问题)

3. 第三范式（3NF）:非主属性的传递不依赖于键码。

 1) 范式要解决的问题：

 - 数据冗余。指表中的一个属性或多个属性发生改变时，会出现多个或更多的属性重复。
 - 插入异常。
 - 删除异常。指删除表中一些没用数据时也会把一些有用的数据同时删除。
 - 更新异常。 所谓更新异常，是指如果某个属性的数据发生改变的时候，就需要对应属性修改很多的数据。

 2) 插入异常举例：
  假设表SelectCourse(学号，姓名，年龄，课程名称,成绩，学分)，有如下关系：
（课程名称）--->（学分）
（学号）------->（姓名，年龄，成绩）
现在，在没有学生选课的情况下，想先插入课程信息（课程名称、学分），会因为没有主键（学号）而出现异常。

---------------------
## 二、事务

 1. **概念**：指满足ACID特性的一组操作，可以提交一个事物或回滚一个事物。
 2. **ACID**：
    -  原子性（Atomicity）:事务被视为不可分割的最小单元。事务的所有操作要么全部成功，要么全部回滚。
    -  一致性（Consistency）：
    -  隔离性 (Isolation)：一个事务在提交前所做的修改对其它事务是不可见的。
    -  持久性 （Durability）：一旦事务提交，所做的修改将永远保存到数据库中。主要是为了应对数据库崩溃的情况。

​    一致性举例：

 ```
 A给B转账5000：
 A=A-5000，B=B+5000
 这时候要两个步骤一起执行才能保持一致性，当只执行了第一个步骤后报错时，就需要用原子性来保证数据状态一致性。

 注意：无并发情况下，满足原子性就能满足一致性，在并发的情况下，还需要满足隔离性，才能满足一致性。

 ```

 3. **并发一致性问题**（数据库隔离级别问题）
    -  丢失修改
    -  脏读数据
    -  不可重复读
    -  幻读

​      产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。

 4. **锁**

   MySQL中的两种封锁粒度：行级锁和表级锁。

   注意：

​         加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

 5. **MySQL隔离级别**

    * 未提交读
    * 提交读
    * 可重复读（MySQL默认隔离级别）
    * 可串行化
---

## 参考
```
  https://blog.csdn.net/devillyd/article/details/51348020
  https://blog.csdn.net/devillyd/article/details/51348020?utm_source=copy

```

