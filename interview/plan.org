* *****找工作*****
** TODO 简历
*** TODO 项目经验
**** TODO JAVA相关
***** TODO 淘淘商城(SpringMVC & Spring & MyBatis )
****** TODO 怎么去把握一个项目？记住每一个细节？
****** TODO 哪里是项目的难点？
***** TODO OA项目
**** TODO Golang相关
***** TODO golang123: https://github.com/fxwfang/golang123
** TODO 面试准备
**** 基础面试题
***** TODO 基础知识整理https://github.com/CyC2018/Interview-Notebook
****** DONE 网络
******* DONE 计算机网络
******* DONE HTTP
****** TODO 操作系统
****** TODO 算法
******* TODO 栈和队列
******** DONE 栈 数组实现
#+BEGIN_SRC java 
public interface MyStack<Item> extends Iterable<Item> {
    MyStack<Item> push(Item item);

    Item pop() throws Exception;

    boolean isEmpty();

    int size();
}
public class ArrayStack<Item> implements MyStack<Item> {
    // 栈元素数组，只能通过转型来创建泛型数组
    private Item[] a = (Item[]) new Object[1];
    // 元素数量
    private int N = 0;

    @Override
    public MyStack<Item> push(Item item) {
        check();
        a[N++] = item;
        return this;
    }

    @Override
    public Item pop() throws Exception {
        if (isEmpty())
            throw new Exception("stack is empty");

        Item item = a[--N];
        check();
        a[N] = null; // 避免对象游离
        return item;
    }

    private void check() {
        if (N >= a.length)
            resize(2 * a.length);
        else if (N > 0 && N <= a.length / 4)
            resize(a.length / 2);
    }

    /**
     * 调整数组大小，使得栈具有伸缩性
     */
    private void resize(int size) {
        Item[] tmp = (Item[]) new Object[size];
        for (int i = 0; i < N; i++)
            tmp[i] = a[i];
        a = tmp;
    }

    @Override
    public boolean isEmpty() {
        return N == 0;
    }

    @Override
    public int size() {
        return N;
    }

    @Override
    public Iterator<Item> iterator() {
        // 返回逆序遍历的迭代器
        return new Iterator<Item>() {
            private int i = N;

            @Override
            public boolean hasNext() {
                return i > 0;
            }

            @Override
            public Item next() {
                return a[--i];
            }
        };
    }
    }

#+END_SRC
******** DONE 栈 链表实现
#+BEGIN_SRC java
public class ListStack<Item> implements MyStack<Item> {
    private Node top = null;
    private int N = 0;

    private class Node {
        Item item;
        Node next;
    }

    @Override
    public MyStack<Item> push(Item item) {
        Node newTop = new Node();
        newTop.item = item;
        newTop.next = top;
        top = newTop;
        N++;
        return this;
    }

    @Override
    public Item pop() throws Exception {
        if (isEmpty())
            throw new Exception("stack is empty");
        Item item = top.item;
        top = top.next;
        N--;
        return item;
    }

    @Override
    public boolean isEmpty() {
        return N == 0;
    }

    @Override
    public int size() {
        return N;
    }

    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {
            private Node cur = top;

            @Override
            public boolean hasNext() {
                return cur != null;
            }

            @Override
            public Item next() {
                Item item = cur.item;
                cur = cur.next;
                return item;
            }
        };
    }
}

#+END_SRC
******* TODO 排序
#+BEGIN_SRC java
public abstract class Sort<T extends Comparable<T>> {

    public abstract void sort(T[] nums);

    protected boolean less(T v, T w) {
        return v.compareTo(w) < 0;
    }

    protected void swap(T[] a, int i, int j) {
        T t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}

#+END_SRC
******** DONE 冒泡排序
#+BEGIN_SRC java 
public class Bubble<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        boolean hasSorted = false;
        for (int i = 0; i < N && !hasSorted; i++) {
            hasSorted = true;
            for (int j = 0; j < N - i - 1; j++) {
                if (less(nums[j + 1], nums[j])) {
                    hasSorted = false;
                    swap(nums, j, j + 1);
                }
            }
        }
    }
}
#+END_SRC
******** DONE 选择排序
#+BEGIN_SRC java 
public class Selection<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++)
                if (less(nums[j], nums[min]))
                    min = j;
            swap(nums, i, min);
        }
    }
}


#+END_SRC
******** DONE 插入排序
#+BEGIN_SRC java
public class Insertion<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 1; i < N; i++)
            for (int j = i; j > 0 && less(nums[j], nums[j - 1]); j--)
                swap(nums, j, j - 1);
    }
}

#+END_SRC
******** TODO 希尔排序
******** TODO 归并排序 (自顶向下归并排序 自低向上归并排序)
******** TODO 快速排序
******** TODO 堆排序
******* TODO 查找
******** TODO 链表实现无序符号表
******** TODO 二分查找实现有序符号表
******** TODO 二叉查找树
******** TODO 2-3查找树
******** TODO 红黑树
******** TODO 散列表

****** TODO 面向对象
******* TODO 设计模式
******* TODO 面向对象思想
******** TODO 三大特性
******** TODO 类图
******** TODO 设计原则
****** TODO 数据库
******* DONE 数据库系统原理
******* DONE MySQL
******** DONE explain的使用
#+BEGIN_SRC   sql explain详解
mysql> explain select * from tb_item_desc;
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | tb_item_desc | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1503 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------+
id : 查询标识.id越大优先查询,id相同自上而下执行
select_type : 查询的类型
1 SIMPLE :简单的SELECT,不使用UNION或子查询
2 PRIMARY :查询中包含任何复杂的子部分,最外层的select被标记为PRIMARY
3 UNION :UNION中第二个或后面的SELECT语句
table : 查询的表
partitions : 
type : 连接类型，表示MySQL在表中找到所需行的方式
4 ALL : full table scan , 遍历全表以找到匹配的行
5 index: full index scan , index与all区别为index类型只遍历索引树
6 range :只检索给定范围的行,使用一个索引来选择行
7 NULL : MySQL在优化过程中分解语句,执行时甚至不用范围表或索引

possible_keys: 可能选择的索引
key : 实际使用的索引
key_len : 使用的索引长度
ref :表的连接匹配条件,即哪些列或常量被用于查找索引列上的值 
rows: 估计查询的行数
filtered : 被条件过滤的的行数的百分比
Extra: 解决查询的一些额外信息
#+END_SRC
******* DONE SQL(视图 存储过程 游标 触发器 权限管理 没看完)
******* TODO Redis
****** TODO Java
******* DONE JVM(粗略浏览)
******* DONE Java基础
******* TODO Java容器
******* TODO JDK中的设计模式
******* TODO Java并发
******* TODO Java教程 https://www.javatpoint.com/java-tutorial
******* TODO Java IO
****** TODO 分布式
******* DONE 分布式基础
******* TODO 一致性协议
******* TODO 分布式问题分析
****** TODO 工具
****** TODO 编程实践

***** TODO 后端技术架构图谱 https://github.com/xingshaocheng/architect-awesome
****** TODO 数据结构 
****** TODO 常用法算
******* 排序_查找算法
******** TODO 快速排序
#+BEGIN_SRC java


#+END_SRC
******** TODO 归并排序
******** TODO 堆排序
******** TODO 计数排序
******** TODO 基数排序
******** TODO 二分查找
******** TODO Java中的排序工具
******* TODO 布隆过滤器
******* TODO 字符串比较(KMP算法)
******* TODO 深度优先&广度优先
******* TODO 贪心算法
******* TODO 回溯算法
******* TODO 剪支算法
******* TODO 动态规划
******* TODO 朴素贝叶斯
******* TODO 推荐算法
******* TODO 最小生成树算法
******* TODO 最短路径算法
****** TODO 并发
******* TODO Java并发
******* DONE Java多线程
******* DONE Java线程安全
****** TODO 操作系统
****** TODO 设计模式
******* DONE 设计模式的六大原则(开闭原则 里氏置换原则 依赖倒转原则 接口隔离原则 迪米特法则 合成复用原则)
******* TODO 23种常见设计模式
******** DONE 单例模式
#+BEGIN_SRC java
//意图：确保一个类只有一个实例,并提供该实例的全局访问点。
#+END_SRC
******** DONE 工厂模式(简单工厂Simple Factory & 工厂方法 Factory Method & 抽象工厂 Abstract Factory)
#+BEGIN_SRC java 
//1.简单工厂(Simple Factory)
//不是设计模式,更像是一种编程习惯,它把实例化的操作单独放到一个类中，这个类就成为工厂类，让工厂类决定应该用哪个子类来实例化。
//意图：在创建一个对象时不向客户暴露接口,并提供一个创建对象的通用接口.

//2.工厂方法(Factory Method)
//意图： 定义了一个创建对象的接口,但由子类决定要实例化哪一个类.

//3.抽象工厂(Abstract Factory)
//意图： 提供一个接口,用于创建相关的对象家族.

#+END_SRC
******** DONE 建造者模式(Builder Pattern)
#+BEGIN_SRC  java
//意图：封装一个对象的构造过程  StringBuilder实现

#+END_SRC
******** DONE 代理模式(Proxy)
#+BEGIN_SRC java 
//意图：提供目标对象之外的访问方式,即通过代理对象访问目标对象,这样做的好处是可以在目标对象的实现基础上,增加额外的功能操作.

//1.静态代理:静态代理在使用时,需要定义接口或父类,被代理对象和代理对象一起实现相同的接口或者父类.
//:注意：代理对象和目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法.
//code:

//2.动态代理 TODO


//3.Cglib代理  TODO

//参考
https://www.cnblogs.com/cenyu/p/6289209.html
https://www.cnblogs.com/vincentzh/p/5988145.html

#+END_SRC
******** TODO 中介者模式(Mediator)
#+BEGIN_SRC java


#+END_SRC
#+BEGIN_SRC java
//意图： 集中相关对象之间复杂的沟通和控制方式.
//Mediator : 中介者,定义一个接口用于与各同事对象通信.
//Collegue : 同事,相关对象



#+END_SRC
******** TODO 观察者模式(Observer)
#+BEGIN_SRC java 
//定义对象之间的一对多依赖,当一个对象状态改变时,它的所有依赖都会收到通知并且自动更新状态.
//主题(Subject):被观察的对象(一的一方),具有注册和移除观察者,并通知所有注册者的功能,通过维护一张列表来实现一系列操作.

//观察者(Observer) : 观察者(多的一方),注册需要调用主题的registerObserver()方法.




#+END_SRC
******** TODO 策略模式(Strategy)
#+BEGIN_SRC 

#+END_SRC
******** TODO 模板方法(Template Method)
#+BEGIN_SRC 

#+END_SRC
******** TODO 适配器模式(Adapter)
******** TODO 桥接模式
******** TODO 装饰者模式
****** TODO 运维 & 统计 & 技术支持
******* TODO Docker技术
****** TODO 中间间
****** TODO 网络
****** TODO 数据库
****** TODO 搜索引擎
****** TODO 性能
****** TODO 大数据
****** TODO 安全
****** TODO 常用开源框架
****** TODO 分布式设计
****** TODO 设计思想 & 开发模式
****** TODO 项目管理
       
* ***** 书籍阅读 ******
** 深入计算机系统
*** TODO 计算机系统漫游
*** TODO 信息的表示和处理
*** TODO 程序的程序级表示
*** TODO 处理器的体系结构
*** TODO 优化程序性能
*** TODO 存储器层次结构
*** TODO 链接
*** TODO 异常控制流
*** TODO 虚拟内存
*** TODO 系统级I/O
*** TODO 网络编程
*** TODO 并发编程
* ***** 视频教程 *****
** 马哥Linux视频教程
*** Linux初级运维
*** Linux中级运维
*** Linux高级运维
**** Tomcat系列
#+BEGIN_SRC  java


//参考资料
//1.https://blog.csdn.net/Zerohuan/article/details/50752635
//2.https://blog.csdn.net/column/details/tomcat8.html
#+END_SRC
** 架构之路
*** Java高并发
*** 深入JVM内核
*** RPC架构
*** Redis集群与应用
*** Dubbo入门到精通
*** Nginx网站架构实现
*** Tomcat负载均衡&调优

* ***** 前端知识 *****
** JavaScript (https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)
*** TODO 快速入门
*** TODO 函数
*** TODO 标准对象
*** TODO 面向对象编程
*** TODO 浏览器
*** TODO JQuery
*** TODO 错误处理
** VUE 

* ***** Golang ***** 
** new 和 make 的区别
** foreach (使用的是副本的方式)
* ***** 学习之道 ****
** 精细化，不要动不动就找一个大的项目，这样不但会有大量的重复工作，也会使自己很疲惫。
** 毕业设计带来的感想: 很多东西是不需要重头开始的，要抓住亮点，突出重点。
** 找工作带来的感想：
*** 职业规划很重要
*** 
