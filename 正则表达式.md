## 正则表达式

[toc]

### 说明

```
作者：老刘
链接：https://www.zhihu.com/question/48219401/answer/742444326
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 元字符

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| .      | 匹配除换行符以外的任意字符   |
| \w     | 匹配字母、下划线、数字或汉字 |
| \s     | 匹配任意的空白符             |
| \d     | 匹配数字                     |
| \b     | 匹配字符的开始或结束         |
| ^      | 匹配字符串的开始             |
| $      | 匹配字符串的结束             |

有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，
比如：

1. 匹配有abc开头的字符串：

```java
1   \babc或者^abc
```

2. 匹配8位数字的QQ号码：

```java
1   ^\d\d\d\d\d\d\d\d$
```

3. 匹配1开头11位数字的手机号码：

```java
1   ^1\d\d\d\d\d\d\d\d\d\d$
```

### 重复限定符

为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符:

| 符号  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复零次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复零初或更多次 |
| {n,m} |                  |

有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：

1. 匹配8位数字的QQ号码：

```java
1   ^\d{8}$
```

2. 匹配1开头11位数字的手机号码：

```java
1   ^1\d{10}$
```

3. 匹配银行卡号是14~18位的数字：

```java
1   ^\d{14,18}$
```

4. 匹配以a开头的，0个或多个b结尾的字符串

```java
1   ^ab*$
```



### 分组

从上面的例子（4）中看到，*限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被*限定那怎么办呢？

> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

因此当我们要匹配多个ab时，我们可以这样
如：匹配字符串中包含0到多个ab开头：

```java
1   ^(ab)*
```

### 转义

我们看到正则表达式用小括号来做分组，那么问题来了：

> 如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？

针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。
如：要匹配以(ab)开头：

```java
1   ^(\(ab\))*
```

### 条件或

回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

```java
1   ^(130|131|132|155|156|185|186|145|176)\d{8}$
```

### 区间

看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？
实际是有的

> 正则提供一个元字符中括号 [] 来表示区间条件。

1. 限定0到9 可以写成[0-9]
2. 限定A-Z 写成[A-Z]
3. 限定某些数字 [165]

那上面的正则我们还改成这样：

```java
1   ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

### 零宽断言

1. 正向先行断言（正前瞻）：

- 语法：（?=pattern）

- 作用：匹配pattern表达式的前面内容，不返回本身。

  这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘</span>’前面的数字内容
  按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=</span>) 就可以匹配到前面的内容了。
  匹配什么内容呢？如果要所有内容那就是：

  ```java
   1   String reg=".+(?=</span>)";
   2
   3   String test = "<span class=\"read-count\">阅读数：641</span>";
   4   Pattern pattern = Pattern.compile(reg);
   5   Matcher mc=    pattern.matcher(test);
   6   while(mc.find()){
   7    System.out.println("匹配结果：")
   8    System.out.println(mc.group());
   9   }
  10
  11   //匹配结果：
  12   //<span class="read-count">阅读数：641
  ```

  可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：

  ```java
  1   String reg="\\d+(?=</span>)";
  2   String test = "<span class=\"read-count\">阅读数：641</span>";
  3   Pattern pattern = Pattern.compile(reg);
  4   Matcher mc=    pattern.matcher(test);
  5   while(mc.find()){
  6     System.out.println(mc.group());
  7   }
  8   //匹配结果：
  9   //641
  ```

2. 正向后行断言（正后顾）:

- 语法：（?<=pattern）

- 作用：匹配pattern表达式的后面的内容，不返回本身。

  有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。
  上面的栗子，我们也可以用后行断言来处理.

  ```java
   1   //(?<=<span class="read-count">阅读数：)\d+
   2   String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
   3
   4   String test = "<span class=\"read-count\">阅读数：641</span>";
   5   Pattern pattern = Pattern.compile(reg);
   6   Matcher mc=    pattern.matcher(test);
   7        while(mc.find()){
   8          System.out.println(mc.group());
   9        }
  10   //匹配结果：
  11   //641
  ```

3. 负向先行断言（负前瞻）

- 语法：(?!pattern)
- 作用：匹配非pattern表达式的前面内容，不返回本身。

有正向也有负向，负向在这里其实就是非的意思。
举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”
现在要找到不是'的花朵'前面的祖国
用正则就可以这样写：

```java
1   祖国(?!的花朵)
```

4. 负向后行断言（负后顾）

- 语法：(?<!pattern)
- 作用：匹配非pattern表达式的后面内容，不返回本身。



### 捕获与非捕获

单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

> 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

而根据命名方式的不同，又可以分为两种组：

1. 数字编号捕获组：
   语法：(exp)
   解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
   比如固定电话的：020-85653333
   他的正则表达式为：(0\d{2})-(\d{8})
   按照左括号的顺序，这个表达式有如下分组：

| 序号 | 编号 | 分组             | 内容         |
| ---- | ---- | ---------------- | ------------ |
| 0    | 0    | (0\d{2})-(\d{8}) | 020-85653333 |
| 1    | 1    | (0\d{2})         | 020          |
| 2    | 2    | (\d{8})          | 85653333     |

我们用Java来验证一下：

```java
 1   String test = "020-85653333";
 2        String reg="(0\\d{2})-(\\d{8})";
 3        Pattern pattern = Pattern.compile(reg);
 4        Matcher mc= pattern.matcher(test);
 5        if(mc.find()){
 6          System.out.println("分组的个数有："+mc.groupCount());
 7            for(int i=0;i<=mc.groupCount();i++){
 8                System.out.println("第"+i+"个分组为："+mc.group(i));
 9            }
10        }
```

输出结果：

```java
1   分组的个数有：2
2   第0个分组为：020-85653333
3   第1个分组为：020
4   第2个分组为：85653333
```

可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。

2. 命名编号捕获组：
   语法：(?<name>exp)
   解释：分组的命名由表达式中的name指定
   比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
   按照左括号的顺序，这个表达式有如下分组：

| 序号 | 名称         | 分组             | 内容         |
| ---- | ------------ | ---------------- | ------------ |
| 0    | 0            | (0\d{2})-(\d{8}) | 020-85653333 |
| 1    | quahog(区号) | (0\d{2})         | 020          |
| 2    | haoma(号码)  | (\d{8})          | 85653333     |

用代码来验证一下：

```java
1   String test = "020-85653333";
2        String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
3        Pattern pattern = Pattern.compile(reg);
4        Matcher mc= pattern.matcher(test);
5        if(mc.find()){
6            System.out.println("分组的个数有："+mc.groupCount());
7            System.out.println(mc.group("quhao"));
8            System.out.println(mc.group("haoma"));
9        }
```

输出结果：

```java
1   分组的个数有：2
2   分组名称为:quhao,匹配内容为：020
3   分组名称为:haoma,匹配内容为：85653333
```

3. 非捕获组：
   语法：(?:exp)
   解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。

比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

```java
1   (?:\0\d{2})-(\d{8})
```

验证一下：

```java
 1   String test = "020-85653333";
 2        String reg="(?:0\\d{2})-(\\d{8})";
 3        Pattern pattern = Pattern.compile(reg);
 4        Matcher mc= pattern.matcher(test);
 5        if(mc.find()){
 6                System.out.println("分组的个数有："+mc.groupCount());
 7                for(int i=0;i<=mc.groupCount();i++){
 8                    System.out.println("第"+i+"个分组为："+mc.group(i));
 9                }
10        }
```

输出结果：

```java
1   分组的个数有：1
2   第0个分组为：020-85653333
3   第1个分组为：85653333
```



### 反向引用

上面讲到捕获，我们知道：***捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用***。

根据捕获组的命名规则，反向引用可分为：

1. 数字编号组反向引用：\k
   或\number
2. 命名编号组反向引用：\k
   或者\'name'


因为捕获组通常是和反向引用一起使用的。

上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用
注意两个字眼：“内容” 和 “使用”
这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住
那这里所说的“使用”是怎样使用呢？

因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。

还是举栗子吧：
比如要查找一串字母"aabbbbgbddesddfiid"里成对的字母
如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，
现在我们先用程序思维理一下思路：

- 1）匹配到一个字母
- 2）匹配第下一个字母，检查是否和上一个字母是否一样
- 3）如果一样，则匹配成功，否则失败

这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？
这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件
好了，有思路就要实践
首先匹配一个字母：\w
我们需要做成分组才能捕获，因此写成这样：(\w)

那这个表达式就有一个捕获组：（\w）
然后我们要用这个捕获组作为条件，那就可以：(\w)\1
这样就大功告成了
可能有人不明白了，\1是什么意思呢？
还记得捕获组有两种命名方式吗，**一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名**
***在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的\***
因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1>或者\1
当然，通常都是是后者。
我们来测试一下：

```java
1   String test = "aabbbbgbddesddfiid";
2        Pattern pattern = Pattern.compile("(\\w)\\1");
3        Matcher mc= pattern.matcher(test);
4        while(mc.find()){
5            System.out.println(mc.group());
6
7        }
```

输出结果：

```java
1   aa
2   bb
3   bb
4   dd
5   dd
6   ii
```

嗯，这就是我们想要的了。

在举个替换的例子，假如想要把字符串中abc换成a

```java
1   String test = "abcbbabcbcgbddesddfiid";
2   String reg="(a)(b)c";
3   System.out.println(test.replaceAll(reg, "$1"));;
```

输出结果：

```java
1   abbabcgbddesddfiid
```

### 贪婪有非贪婪

**1.贪婪**

我们都知道，贪婪就是不满足，尽可能多的要。
在正则中，贪婪也是差不多的意思:

> 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
> 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。

前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：

```java
1   \d{3,6}
```

用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。
如

```java
1   String reg="\\d{3,6}";        
2   String test="61762828 176 2991 871";
3   System.out.println("文本："+test);
4   System.out.println("贪婪模式："+reg);
5   Pattern p1 =Pattern.compile(reg);
6   Matcher m1 = p1.matcher(test);
7    while(m1.find()){
8      System.out.println("匹配结果："+m1.group(0));
9   }
```

输出结果：

```java
1   文本：61762828 176 2991 44 871
2   贪婪模式：\d{3,6}
3   匹配结果：617628
4   匹配结果：176
5   匹配结果：2991
6   匹配结果：871
```

由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。
一个量词就如此贪婪了，
那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

> 是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。

```java
1   String reg="(\\d{1,2})(\\d{3,4})";        
2   String test="61762828 176 2991 87321";
3   System.out.println("文本："+test);
4   System.out.println("贪婪模式："+reg);
5   Pattern p1 =Pattern.compile(reg);
6   Matcher m1 = p1.matcher(test);
7    while(m1.find()){
8      System.out.println("匹配结果："+m1.group(0));
9     }
```

输出结果：

```java
1   文本：61762828 176 2991 87321
2   贪婪模式：(\d{1,2})(\d{3,4})
3   匹配结果：617628
4   匹配结果：2991
5   匹配结果：87321
```

1. “617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628
2. "2991" 是前面的\d{1,2}匹配出了29 ，后面的匹配出了91
3. "87321"是前面的\d{1,2}匹配出了87，后面的匹配出了321

**2. 懒惰（非贪婪）**

> 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

懒惰量词是在贪婪量词后面加个“？”

| 代码   | 说明                            |
| ------ | ------------------------------- |
| *？    | 重复任意次，但尽可能少重复      |
| +？    | 重复1次或更多次，但尽可能少重复 |
| ??     | 重复0次或1次，但尽可能少重复    |
| {n,m}? | 重复n到m次，但尽可能少重复      |
| {n,}?  | 重复n次以上，但尽可能少重复     |

```java
1   String reg="(\\d{1,2}?)(\\d{3,4})";        
2        String test="61762828 176 2991 87321";
3        System.out.println("文本："+test);
4        System.out.println("贪婪模式："+reg);
5        Pattern p1 =Pattern.compile(reg);
6        Matcher m1 = p1.matcher(test);
7        while(m1.find()){
8            System.out.println("匹配结果："+m1.group(0));
9        }
```

输出结果：

```java
1   文本：61762828 176 2991 87321
2   贪婪模式：(\d{1,2}?)(\d{3,4})
3   匹配结果：61762
4   匹配结果：2991
5   匹配结果：87321
```

解答：

> “61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762
> "2991"  是左边的懒惰匹配出2，右边的贪婪匹配出991
> "87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321

### 反义

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

| 元字符   | 解释                                       |
| -------- | ------------------------------------------ |
| \W       | 匹配任意不是字母、下划线、数字、汉字的字符 |
| \S       | 匹配任意不是空白符的字符                   |
| \D       | 匹配任意非数字的字符                       |
| \B       | 匹配不是单词开头或结束的位置               |
| [^x]     | 匹配除了x以外的任意字符                    |
| [^aeiou] | 匹配除了aeiou以外的任意字符                |

### awk

```
awk
```



### sed

```
sed
```



### 练习题

```
1.给一个连字符串例如：get-element-by-id转化成驼峰形式。
2.匹配二进制数字
3.非零的十进制数字 (有至少一位数字, 但是不能以0开头)
4.匹配一年中的12个月
5.匹配qq号最长为13为
6.匹配常见的固定电话号码
7.匹配ip地址
8.匹配用尖括号括起来的以a开头的字符串
9.分割数字每三个以一个逗号划分
10.判断字符串是否包含数字
11.判断电话号码
12.判断是否符合指定格式
13.判断是否符合USD格式
14.JS实现千位分隔符
15.获取 url 参数
16.验证邮箱
17.验证身份证号码
18.匹配汉字
19.去除首尾的'/'
20.判断日期格式是否符合 '2017-05-11'的形式，简单判断，只判断格式
21.判断日期格式是否符合 '2017-05-11'的形式，严格判断（比较复杂）
22.IPv4地址正则
23.十六进制颜色正则
24.车牌号正则
25.过滤HTML标签
26.密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
27.URL正则
28.匹配浮点数
```



### 资料

正则表达式： https://www.zhihu.com/question/48219401/answer/742444326

sed和awk用法： https://www.cnblogs.com/leedaily/p/8329445.html

