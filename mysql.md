### MySQL

[toc]

问题列表

```
1.
2. 
```



### 隔离级别

| RAED  UNCOMMITED 读取未提交内容 | 使用查询语句不会加锁，可能会读到未提交的行（Dirty  Read）    |
| ------------------------------- | ------------------------------------------------------------ |
| READ COMMITED 读取提交内容      | 只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，     所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）； |
| REPEATABLE READ 可重复读        | 多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom  Read）；通过行级锁+MVCC实现 |
| SERIALIZABLE 串行化             |                                                              |

### 锁类型

| 共享锁（S  Lock） | Shared  Locks,允许其他事务再加共享锁，不允许其他事务再加排他锁；select…lock in share mode |
| ----------------- | ------------------------------------------------------------ |
| 排它锁 (X Lock)   | Exclusive  Locks,其它事务无法再对该数据加共享或者排他锁。select…for update |

### 锁种类

|                       | 加锁是加在索引上的                                           |
| --------------------- | ------------------------------------------------------------ |
| 表级锁                | 是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，     被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁分为表共享读锁与表独占写锁。 |
| 行级锁                | 是mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但是加锁的开销也最大，行级锁分为共享锁和排它锁。 |
| 页级锁                |                                                              |
| GAP锁（间隙锁）       | 在RR隔离级别下，为了防止幻读，于是有gap锁和next-key锁存在，除了对唯一索引的唯一搜索外都会获取gap锁或next-key锁。即锁住其扫描的范围。 |
| 意向锁                | Intention Locks,  innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。 |
| 意向共享锁（IS Lock） | 事务想要获得一张表中某几行的共享锁                           |
| 意向排他锁（IX Lock） | 事务想要获得一张表中某几行的排他锁；                         |
| 死锁                  | 事物A持久资源1的锁，事务B持有资源2的锁、事务A等待资源2的锁，事务B等待资源1的锁 |

### MVCC  多版本控制（Multiversion Concurrency Control）

|               | MVCC概念        | 多版本控制（Multiversion Concurrency  Control）:  指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，InnoDB通过undo  log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。      MVCC在 Read Committed 和 Repeatable  Read两个隔离级别下工作。     MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读)，是通过  "行级锁+MVCC"一起实现的，正常读的时候不加锁，写的时候加锁。而 MVCC 的实现依赖：隐藏字段、Read View、Undo  log。 |
| ------------- | --------------- | ------------------------------------------------------------ |
| 隐藏字段      |                 | InnoDB存储引擎在每行数据的后面添加了三个隐藏字段             |
|               | DB_TRX_ID       | 6字节，表示最近一次对本激励行作修改（insert\|update）的事务ID。至于delete操作,InnoDB认为是一个update操作，不过会更新一个另外的删除位，将表示为deleted.并非真正的删除。 |
|               | DB_ROLL_PTR     | 7字节，回滚指针，指向当前记录行的undo log信息                |
|               | DB_ROW_ID       | 6字节，随着新行插入而单调递增的行ID。理解：当表没有主键或唯一非空索引时，innodb就会使用这个行ID自动产生聚簇索引。如果表有主键或唯一非空索引，聚簇索引就不会包含这个行ID了。这个DB_ROW_ID跟MVCC关系不大。 |
| Read View结构 |                 | 其实Read  View（读视图），跟快照、snapshot是一个概念。 Read View主要是用来做可见性判断的, 里面保存了“对本事务不可见的其他活跃事务”。 |
|               | low_limit_id    | 目前出现过的最大的事务ID+1，即下一个将被分配的事务ID         |
|               | up_limit_id     | 活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id |
|               | trx_ids         | Read  View创建时其他未提交的活跃事务ID列表，创建Read  View时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。 |
|               | creator_trx_id  | 当前创建事务的ID，是一个递增的编号                           |
| Undo log      |                 | Undo  log中存储的是老版本数据，当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。 |
|               | insert undo log | 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。 |
|               | update undo log | 事务对记录进行delete和update操作时产生的undo  log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 |

### ACID

| Atomicity  原子性  | 事务一起成功或一起失败,回滚日志 undo log实现 |
| ------------------ | -------------------------------------------- |
| Consistency 一致性 | 表示事务完成后，符合逻辑运算                 |
| Isolation 隔离性   | 排除其他事务对本事务的影响                   |
| Durability 持久性  | 事务结束后的数据不随着外界原因导致数据丢失   |

### 引擎

| MyISAM |               |                      |
| ------ | ------------- | -------------------- |
|        | tableName.frm | frame表结构          |
|        | tableName.myd | myISAM data数据文件  |
|        | tableName.myi | myISAM index索引文件 |
| InnoDB |               |                      |
|        | tableName.frm | frame结构文件        |
|        | tableName.ibd | 索引、数据集合文件   |

### 索引

| 分类 |          |                                    |
| ---- | -------- | ---------------------------------- |
|      | 聚集索引 | 就是叶子节点包含完整的数据列       |
|      | 稀疏索引 | 如MyISAM，叶子节点只包含数据的指针 |

### 索引优化

| 全值匹配               | 用等于查询                               |
| ---------------------- | ---------------------------------------- |
| 最左前缀               | 从索引的最左前列开始并且不跳过索引中的列 |
| 不要在索引上做任何操作 | 运算、函数、类型转换等                   |
| explain                |                                          |

### 数据库开发规范

```
* 数据库命名规范		
	1.所有的数据库对象名称必须使用小写字母并用下划线分割	mysql数据库大小写敏感。例如: 不同的数据库名  DbName dbname 不同的表名 Table table taBLe
	2.所有数据库对象名称禁止使用mysql保留关键字	例如 ：select id , username , from ,age from table_user 会造成mysql 歧义
	3.数据库对象的命名要做到见名识义，并且最好不要超过32个字符	
	4.所有的临时表必须义tmp为前缀并且已日期为后缀，备份库备份表必须义bak为前缀并且已日期为后缀	
	5.所有的数据存储的列名和列类型必须一致？？
  
* 存储规范		
	1.所有的表必须使用Innodb存储引擎 	支持事物行级锁，更好的恢复性，并发性能更好
	2.大部分数据库表字符集要统一	
	3.所有的表和字段都要添加注释	
	4.尽量控制单表的数据量大小，建议控制在500万以内	过大可以通过历史数据归档，分库分表的手段来控制数据量的大小
	5.尽量做到冷热数据分离，减少表的宽度	列最大4096列，减少磁盘io,保证热数据的内存缓存命中率，控制列数量也可以更加有效的利用缓存，避免读入无用的冷数据经常使用的列放在一个表中
	6.禁止在表中建立预留字段	预留字段命名很难做到见识义，无法选择合适的类型，对预留字段修改会对表进行锁定

* 行为规范		
	1.禁止存储图片，文件等二进制文件，造成大量的io操作	
	2.禁止再线上进行数据库的压力测试	
	3.禁止从开发环境测试环境直连生产环境	
* 数据库索引设计规范		
	1.建议单表索引数量不超过5个	索引并不是越多越好过多索引降低效率，优化器过多索引选出最优解，innodb 是按照哪个索引的顺序来组织表的呢？ 主键。不使用更新频繁的列作为主键，不使用多列主键。不使用uuid,md5,hash 字符串列作为主键  不能保证顺序增长。
	2.那些哪些列上建立索引	1.经常在select update delete语句的where从句的列建立索引 2.包含在order by , group by , distinct 中的字段 3.多表join的关联列
	3.如何选择索引的顺序？	"联合索引中索引从左到右的顺序。 建立索引的目的是为了查询数据的时候可以根据索引来进行数据查找-- 从而减少磁盘的随机io , 增加查询的性能，所以
 如果我们的索引能够过滤出更少的数据那么我们从磁盘读入的数据则越少。1.区分度最高的列放在联合索引的最左侧 区分度--数据唯一值的数量/总行数 区分度最大的就应该是主键了
   2.尽量字段长度小的列放在联合索引的最左侧 
   3.使用最频繁的列放在最左侧 
   4，尽量避免冗余和重复的索引   重复索引了： primary key(id) , index(id) , unique index(id)
      冗余： index(a,b,c) , index(a.b)
   5.对于频繁使用的查询先优先考虑覆盖索引（包含了所有的查询字段的索引）
   6.尽量使用外键 不建议使用外检约束，但是一定要在表与表之间的关联键上建立索引"
   
* 数据库字段设计规范		
	1.优先选择符合存储需要的最小的数据类型	 1.将字符串转换成数字类型存储  INET_ATON('255.255.255.255') = 4294967295 字符串转ip 2.对于非负数据采用无符号整形进行存储  signed int -2147483648 -- 2147483647 3.VARCHAR(N)中的N代表的是字符数而不是字节数 4.过大的长度会消耗更多的内存 varchar是一个可变的长度
	2.避免使用text,blob数据类型	建议blob或者时text分离到单独的表中，避免使用enum数据类型
	3.尽可能的所有列都定义为NOT NULL	索引null列需要额外的空间来保存，所以需要占用更多的空间，进行比较和计算的时候要对null值进行特别的处理
	4.字符串存储日期型的数据不是正确的	无法用日期函数来进行计算和比较，用字符串存储日期要占用更多的空间
	5.财务相关的金额类数据，必须由decimal类型存储	decimal类型为精准的浮点数，在计算时不会丢失精度

* 数据库的sql开发规范		
	1.建议使用预编译语句对数据库进行操作	
	2.避免数据类型的隐式转换,不同表的相同列的数据类型不一致,会导致索引失效	
	3.重复利用已经存在的索引	" 1.避免使用双%%的查询条件 如 a like '%1323%'
    2.一个sql只能利用到复合索引中的一列进行范围查询
    有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，
    在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧
    3.使用left join 或者not exists 来优化not in（偶尔也会导致索引失效） 操作 "
	4.程序链接不同数据库要使用不同的账号，禁止跨库连接为迁移和分库分表做预备	
	5.禁止select * 必须使用select <字段列表> （* 无法覆盖索引  减少表结构变更 对程序带来的影响）	
	6.insert 明确字段列表	
	7.禁止使用子查询，可以把子查询优化为join操作	子查询结果集无法使用索引，子查询会产生临时表操作，如果子查询数据量大则会更严重
	8.避免使用过多的join 关联表	"于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置
   在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，
   所占用的内存也就越大
   如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，
   就会影响到服务器数据库性能的稳定性
   同时对于关联操作来说，会产生临时表操作，影响查询效率
   Mysql最多允许关联61个表，建议不超过5个    "
	9.减少同数据库的交互次数 多个相同的操作合并在一起	
	10.对应同一列进行or判断时，使用in代替or	in的值不要超过500个，in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引
	11.禁止order by rand() 进行随机排序	
	12.where从句禁止对列进行函数转换和计算(导致无法使用相关列的索引)	
	13.不会有重复值时使用UNION ALL，而不是UNION	UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作，UNION ALL 不会再对结果集进行去重操作
	14.拆分大sql变为小sql	

* 数据库操作行为规范		
	过大数据的（100万）批量写操作要分批多次操作	
	1.大批量操作可能会导致严重的主从延迟	
	2. binlog日志为row格式时会产生大量的日志	"大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，
   产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因"
	3. 避免产生大事务操作	
	4.对于大表的修改使用pt-online-schema-change	.原理： 会在原表的结构上建造一个新表 复制数据  2.避免延迟，修改时锁表
	5.禁止super权限滥用	
	6.数据账号连接最小	
```

### 执行计划分析

