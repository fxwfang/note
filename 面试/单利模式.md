## 单利模式

------

[toc]

### 问题

```
0. 单利模式中有什么要注意的点？
1. 饿汉式为什么是线程安全的，是由什么保障的？  -- 类加载机制、
2. 双重锁模式中静态变量为什么要加volitile修饰
3. 静态内部类实现的单例中，静态内部类是什么时候加载的

```

### 目标是什么？

  保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 关键点

* 私有化构造方法
* 通过一个静态方法或枚举返回单例类对象
* 确保单例类的对象有且只有一个，尤其是多线程环境下
* ***确保单例类对象在反序列化时不会重新构建对象***

### 代码实现

* 饿汉式（线程安全）

```java
    class Singleton {
        private static Singleton instance = new Singleton();

        private Singleton() {
        }

        public static getInstance() {
            return this.instance;
        }
    }
```

问题： 是什么保证上面的代码是线程安全的？

1. 调用一个类的静态方法的时候会触发类的加载（如果类没加载过）
2. 类只会加载（被加载到虚拟机内存的过程，包括5个阶段）一次
3. static变量在类初始化的时候（类加载过程的最后一个阶段）会去赋值静态变量

* 双重锁DCL

```java
// 3.双重锁DCL（为什么要加上volitile，解释一下原因，指令重排）
 class Singleton{
   private Singleton(){}
   private static volitile Singleton instance =null;
   public static getInstance(){
     
     if(instance == null){
       sychcronize(this){
         if(instance == null){
            instance = new Singleton();
         }
       }
     }
     return instance;
   }
 }


```

* 内部类

```java

 class Singleton{
  private Singleton(){}
  private static class Holder{ public static Singleton instance = new Singleton();}
   public static getInstance(){
     return Holder.instance;
   }
 }

```



### 参考

* [深入理解单例模式：静态内部类单例原理](https://blog.csdn.net/mnb65482/article/details/80458571)
* [面试官：你简历写着熟悉设计模式，那说说单例模式实现及线程安全吧](https://zhuanlan.zhihu.com/p/167914411)
* [volatile 原理，怎么使cpu 三级缓存中的那些数据失效](./volatile原理.md)

