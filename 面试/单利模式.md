## 单利模式

------

[toc]



### 一.问题是什么？

```


```

### 二、为什么要限制单利？

```
1. 功能场景上需要做限制，比如多台电脑连到一台打印机，就需要限制只有一个打印机实例，只能有一个正在工作的任务。否则会出现打印混乱的情况。
2. 从程序设计上，避免了类实例的频繁创建和销毁，提升性能。
```

### 三、目标是什么？

```
  保证一个类仅有一个实例，并提供一个访问它的全局访问点。
```

### 四、如何去实现？

```java
// 1. 空间置换时间,类加载的时候就进行实例化（饿汉式，线程安全）
 class Singleton{
   private static Singleton instance =new Singleton();
   public static getInstance(){
     return this.instance;
   }
 }

//2. 懒汉式
 class Singleton{
   private static Singleton instance =null;
   public static getInstance(){
     if(instance == null){
       instance = new Singleton();
     }
     return instance;
   }
 }
// 3.双重锁（为什么要加上volitile，解释一下原因，指令重排）
 class Singleton{
   private static volitile Singleton instance =null;
   public static getInstance(){
     
     if(instance == null){
       sychcronize(this){
         if(instance == null){
            instance = new Singleton();
         }
       }
     }
     return instance;
   }
 }
// 4.内部类
 class Singleton{
  private static class Holder{ public static Singleton instance = new Singleton();}
   public static getInstance(){
     return Holder.instance;
   }
 }


```

### 五、衍生问题

#### 1. 静态变量与静态代码块的加载顺序？

#### 2. 类中的static变量在创建类时会创建多次吗？如果不会，怎么做到只创建一次的？

```java
代码示例：
class Demo{
		private static int count = 0;
		public int getAndIncrease(){
				return count ++ ;
		}
}
class Main{
		public static void main(String []args){
      // 为什么不是每次new Demo()的时候count就重置？
			 Demo1 d1 = new Demo();
			 Sysout.out.println("d1 count:"+d1.getAndIncrease(););
			 Demo2 d2. = new Demo();
			 System.out.println("d2 count:"+d2.getAndIncrease(););
			 
		}
}

```

​      

### 参考

* [深入理解单例模式：静态内部类单例原理](https://blog.csdn.net/mnb65482/article/details/80458571)

