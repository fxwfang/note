### 函数式编程
```
import leetcode.DataBean;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * 计算 集合中 DeptId 和 Type 相同的数据的num总和。需求很常见，看着很简单，各位写写看？
 */
public class Main7 {
    public static void main(String[] args) {
        List<DataBean> totalStocks = new ArrayList<>();

        DataBean stock1 = new DataBean();
        stock1.setDeptId(2);
//        stock1.setType(2);
        stock1.setNum(2);
        totalStocks.add(stock1);

        DataBean stock2 = new DataBean();
        stock2.setDeptId(2);
//        stock2.setType(2);
        stock2.setNum(3);
        totalStocks.add(stock2);

        DataBean stock3 = new DataBean();
        stock3.setDeptId(3);
        stock3.setType(3);
        stock3.setNum(5);
        totalStocks.add(stock3);

        DataBean stock4 = new DataBean();
        stock4.setDeptId(3);
        stock4.setType(3);
        stock4.setNum(4);
        totalStocks.add(stock4);

        DataBean stock5 = new DataBean();
        stock5.setDeptId(4);
        stock5.setType(4);
        stock5.setNum(10);
        totalStocks.add(stock5);

        //group
        Map<String, List<DataBean>> collect = totalStocks.stream()
                .collect(Collectors.groupingBy(e -> e.getDeptId() + ":" + e.getType()));
        System.out.println(collect);
        //分组后的list做reduce操作
        Stream<DataBean> dataBeanStream = collect.values().stream().map(list -> list.stream().reduce(Main7::combine).get());
        dataBeanStream.forEach(v-> System.out.println(v));
/**
 * Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
 *     at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
 *     at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
 *
 *     Java8 Stream 已经被操作或关闭
 *
 * 重用流
 *        Supplier<Stream<List<DataBean>>> streamSupplier = ()->Stream.of(totalStocks);
 *         streamSupplier.get().forEach(v-> System.out.println(v));
 *
 */
//        List<DataBean> collect1 = dataBeanStream.collect(Collectors.toList());
//        System.out.println(collect1);
        Supplier<Stream<List<DataBean>>> streamSupplier = ()->Stream.of(totalStocks);
        streamSupplier.get().forEach(v-> System.out.println(v));

     }

    private static DataBean combine(DataBean dataBean, DataBean dataBean1) {

        DataBean e  = new DataBean();
        e.setDeptId(dataBean.getDeptId());
        e.setType(dataBean.getType());
        e.setNum(dataBean.getNum()+dataBean1.getNum());
        return e;
    }


}
@Data
class DataBean {

    private int type;

    private int deptId;

    private int num;
}



错误写法：
//groupMap<String, List<DataBean>> gourps = totalStocks.stream()
 .collect(Collectors.groupingBy(e -> e.getDeptId() + ":" + e.getType()));
// reduce（错误的写法）List<DataBean> result = gourps.values().stream()
      .reduce(list -> list.stream().reduce((e1, e2) -> {
      e2.setNum(e1.getNum() + e2.getNum());
 return e2;}).get())// toList.collect(Collectors.toList());
System.out.println(result);

函数式强调函数必须是纯函数，不能修改数据，而且是幂等，在stream里面，任何修改数据的行为都是不应该的，修改数据的时候应该返回新对象。所以在里面set数据的，或者往list里面增加数据的，都是不好的写法！



```