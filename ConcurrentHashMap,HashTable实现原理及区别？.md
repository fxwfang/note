### ConcurrentHashMap,HashTable实现原理及区别？



# 常见的hash算法及其原理（https://blog.csdn.net/Beyond_2016/article/details/81286360）

Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

　　哈希表是根据设定的哈希函数H（key）和处理冲突方法将一组关键字映射到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。作为线性数据结构与表格和队列等相比，哈希表无疑是查找速度比较快的一种。

　　通过将单向数学函数（有时称为“哈希算法”）应用到任意数量的数据所得到的固定大小的结果。如果输入数据中有变化，则哈希也会发生变化。哈希可用于许多操作，包括身份验证和数字签名。也称为“消息摘要”。

　　简单解释：哈希（Hash）算法，即散列函数。它是一种单向密码体制，即它是一个从明文到密文的不可逆的映射，只有加密过程，没有解密过程。同时，哈希函数可以将任意长度的输入经过变化以后得到固定长度的输出。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。

​     散列表，它是基于快速存取的角度设计的，也是一种典型的“空间换时间”的做法。顾名思义，该数据结构可以理解为一个线性表，但是其中的元素不是紧密排列的，而是可能存在空隙。

　　散列表（Hash table，也叫哈希表），是根据关键码值（Key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

　　比如我们存储70个元素，但我们可能为这70个元素申请了100个元素的空间。70/100=0.7，这个数字称为负载因子。我们之所以这样做，也是为了“快速存取”的目的。我们基于一种结果尽可能随机平均分布的固定函数H为每个元素安排存储位置，这样就可以避免遍历性质的线性搜索，以达到快速存取。但是由于此随机性，也必然导致一个问题就是冲突。所谓冲突，即两个元素通过散列函数H得到的地址相同，那么这两个元素称为“同义词”。这类似于70个人去一个有100个椅子的饭店吃饭。散列函数的计算结果是一个存储单位地址，每个存储单位称为“桶”。设一个散列表有m个桶，则散列函数的值域应为［0，m-1］。

　　解决冲突是一个复杂问题。



# Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题



https://blog.csdn.net/qq_27093465/article/details/52279473

知识点：

* synchronized  /ˈsɪŋkrənaɪzd/
* volatile /ˈvɒlətaɪl/





# 为什么静态成员、静态方法中不能用this和super关键字



  在静态方法中是不能使用*this*预定义对象引用的*,*即使其后边所操作的也是静态成员也不行*.
*因为*this*代表的是调用这个函数的对象的引用*,*而静态方法是属于类的*,*不属于对象*,*静态方法成功加载后*,*对象还不一定存在

 

*2.*   在问题之前先讲*super*的用法：*
1.super*的用法跟*this*类似，*this*代表对本类对象的引用，指向本类已经创建的对象；而*super*代表对父类对象的引用，指向父类对象；*
2.*静态优先于对象存在；*
3.*由上面的*1.*和*2.*知：*
*因为静态优先于对象存在，所以方法被静态修饰之后方法先存在，而方法里面要用到*super*指向的父类对象，但是所需的父类引用对象晚于该方法出现，也就是*super*所指向的对象没有，当然就会出错。*
*综上，静态方法中不可以出现*super*关键字。

 https://blog.csdn.net/u010479322/article/details/51730275

评论：

我的理解是因为静态方法和静态变量都是先加载的，所以this无法指向任何位置才会报错，如果在静态方法里面先实例化对象是可以在方法内调用类内的其他方



** 支持评论区说法， jvm虚拟机的类加载机制问题



https://blog.csdn.net/qq_35190492/article/details/103847147?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param

















