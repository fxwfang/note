#                                  高并发学习

1. 如果有5个步骤的程序，每个步骤消耗100个时间单位。假设步骤2和步骤5可以完全并行，并且你有无穷多个处理器。那么根据Amdahl加速比是多少?



```java
// Amdahl定律:阿姆达尔定律,定义了串行化后的加速比的计算公式和理论上限

//   加速比=优化前系统耗时/优化后系统耗时


```



2. 举出 日常生活中死锁的例子（小车死锁已经哲学家就餐不能作为本题答案）

```java

//哲学家就餐问题:




//生活中的死锁例子




```



3.  现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行 

```java
//answer:



//类似问题
写程序实现三个线程，线程1只能输出a,线程2只能输出b，线程3只能输出c,要求最终实现10个abc.


```



4. 使用 wait notify 实现一个队列，队列有2个方法，add 和 get 。add方法往队列中添加元素，get方法往队列中获得元素。队列必须是线程安全的。如果get执行时，队列为空，线程必须阻塞等待，直到有队列有数据。如果add时，队列已经满，则add线程要等待，直到队列有空闲空间。

```java
//



```



5. 实现这么一个队列，并写一个测试代码，使他工作在多线程的环境下，证明，它的工作是正确的。给出程序和运行的截图。

```java

//



```

6. 写一个程序，证明在32位hotspot上，long不是原子操作，给出程序，以及运行的截图。

```java
//


```

7. 网上有些文章说，volatile不能保证原子性，但是，课程里却说，volatile可以保证原子性，你怎么看这个问题 

```java
//




```



8. 实现一个无锁的Stack，并写一段测试代码（多线程访问），证明这个Stack是线程安全的。给出程序以及运行的截图。

   ```java
   
   
   
   ```

   

9. 比较 ConcurrentLinkedQueue 和 BlockingQueue的性能，并说明为什么。给出你的测试代码，和运行结果的截图。

   ```java
   
   
   
   ```

   

10. 分析CopyOnWriteArrayList的核心代码，说明CopyOnWriteArrayList如何提高并行度。

11. 线程池会吃掉堆栈，能不能想办法，在异常的时候 打印出 提交任务的线程的堆栈？给出你的实现代码和截图。

12. 请你阅读以下JDK 8的ForkJoinPool的代码，为它的scan()方法写一下详细的注释，说明它的基本原理。 

13. 综合到目前为止的所有课程，实现这么一个并发算法：计算给定函数 y=1/x 在定义域 [1,100]上围城与X轴围成的面积，计算步长0.01 

14. 分别使用NIO和AIO实现一个Server。接收客户端的一个四则混合运算表达式，计算结果后，将其返回给Client。提交这2个代码，以及运行后的截图

15.  写一段简单的代码，测试使用偏向锁和禁用偏向锁的性能差异。给出你的jdk版本，程序运行时jvm参数，以及输出结果和结论

16. 写2个程序，实现2个线程的死锁。并使用jstack分析这个结果。（分别使用synchronized和ReenterantLock实现），给出你的代码，以及jstack的分析的截图和说明。

17. 测试StampedLock和读写锁在 大量读和少量写的场景下的性能，比如20个线程读，一个线程写的场景。给出测试代码和你的测试结果截图。

18. 在QueuedThreadPool的实现中，使用了自定义的BlockingQueue——BlockingArrayQueue。请你阅读它的实现代码，给出它的实现主要逻辑。（poll和offer方法的实现），请你关注并且重点解释_indexes变量的用意。（使用jetty 9.2.10v20150310版本）

19. 请你阅读ArrayByteBufferPool的代码。为它的acquire和release方法写上详细的注释。尤其需要说明bucketFor()函数的含义和作用。









## 一些重要概念

```java
//同步(synchronous) 和 异步(asynchronous)

//并发(Concurrency)和并行(Parallelism)

//临界区

//阻塞(Blocking) 和非阻塞(Non-Blocking)

//死锁(Deadlock) 饥饿(Starvation) 活锁(LiveLock)


//并发级别
// 阻塞  非阻塞(无障碍Obstruction 无锁Lock-Free 无等待Wait-Free)





```







































